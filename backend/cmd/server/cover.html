
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Rzh3nk/quizzix/backend/cmd/server/answerHandler.go (100.0%)</option>
				
				<option value="file1">github.com/Rzh3nk/quizzix/backend/cmd/server/categoryHandler.go (0.0%)</option>
				
				<option value="file2">github.com/Rzh3nk/quizzix/backend/cmd/server/leaderboardHandler.go (0.0%)</option>
				
				<option value="file3">github.com/Rzh3nk/quizzix/backend/cmd/server/main.go (0.0%)</option>
				
				<option value="file4">github.com/Rzh3nk/quizzix/backend/cmd/server/questionHandler.go (0.0%)</option>
				
				<option value="file5">github.com/Rzh3nk/quizzix/backend/cmd/server/quizHandler.go (0.0%)</option>
				
				<option value="file6">github.com/Rzh3nk/quizzix/backend/cmd/server/testHandler.go (0.0%)</option>
				
				<option value="file7">github.com/Rzh3nk/quizzix/backend/cmd/server/userHandler.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "net/http"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
)

func getAnswers(c *gin.Context) <span class="cov8" title="1">{
        questionID := c.Param("id")
        var answers []models.Answer
        if err := db.Where("question_id = ?", questionID).Find(&amp;answers).Error; err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, answers)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "net/http"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
)

func getCategories(c *gin.Context) <span class="cov0" title="0">{
        var categories []models.Category
        if err := db.Find(&amp;categories).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, categories)</span>
}
func getCategoryQuizzes(c *gin.Context) <span class="cov0" title="0">{
        categoryID := c.Param("id")
        var quizzes []models.Quiz
        if err := db.Where("category_id = ?", categoryID).Find(&amp;quizzes).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, quizzes)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "net/http"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
)

func getLeaderboard(c *gin.Context) <span class="cov0" title="0">{
        var users []models.User
        if err := db.Order("total_points DESC").Limit(100).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, users)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "log"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
        "github.com/glebarez/sqlite"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

var db *gorm.DB

func main() <span class="cov0" title="0">{
        var err error
        db, err = gorm.Open(sqlite.Open("quizzix.db"), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("SQLite не подключен:", err)
        }</span>
        <span class="cov0" title="0">if err := db.AutoMigrate(
                &amp;models.User{},
                &amp;models.Category{},
                &amp;models.Quiz{},
                &amp;models.Question{},
                &amp;models.Answer{},
                &amp;models.Result{},
        ); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Ошибка", err)
        }</span>
        <span class="cov0" title="0">seedDemoData()

        //раутеры
        r := gin.Default()
        r.GET("/api/quizzes", getQuizzes)
        r.GET("/api/categories/:id/quizzes", getCategoryQuizzes)
        r.GET("/api/categories", getCategories)
        r.GET("/api/quizzes/:id/questions", getQuestions)
        r.GET("/api/question/:id/answers", getAnswers)
        r.GET("/api/users/:id", getUser)
        r.POST("/api/register", register)
        r.POST("/api/login", login)
        r.POST("/api/quizzes/:id/submit", checkTest)
        r.GET("/api/users/:id/results", getUserResults)
        r.GET("/api/leaderboard", getLeaderboard)
        r.POST("/api/quizzes", createQuiz)
        log.Println("Backend запущен")

        r.Run(":8080")</span>
}

// тестовые данные
func seedDemoData() <span class="cov0" title="0">{
        var count int64
        db.Model(&amp;models.Quiz{}).Count(&amp;count) //считает количество квизов в бд
        if count &gt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">testhash, _ := bcrypt.GenerateFromPassword([]byte("test"), bcrypt.DefaultCost)

        db.Create(&amp;models.User{Username: "test", Email: "test@mail.ru", Password: string(testhash)})
        db.Create(&amp;models.Category{Name: "Наука", Description: "В этой категории представленые науные квизы", ImgURL: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRpHNKGMwFfIP-QDg_IL1rph5c4Pa5jLos4uA&amp;s"})
        db.Create(&amp;models.Category{Name: "Кино", Description: "В этой категории представленые квизы по кино", ImgURL: "https://1gai.ru/uploads/posts/2021-08/1628577646_1.png"})
        db.Create(&amp;models.Category{Name: "История", Description: "В этой категории представленые исторические квизы", ImgURL: "https://impulse35.ru/wp-content/uploads/2023/11/depositphotos_2478371-stock-photo-old-magnifying-glass-on-word.webp"})

        db.Create(&amp;models.Quiz{Title: "Квиз по науке", Description: "Описание квиза по науке", CategoryID: 1, ImgURL: "https://img.championat.com/news/big/c/x/formula-1-chto-eto-za-sport_17582327151452255140.jpg"})
        db.Create(&amp;models.Quiz{Title: "Квиз по кино", Description: "Описание квиза по кино", CategoryID: 2, ImgURL: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRt746EWWaQ2LSMRlfzNNn2f3FTiAU8Vz6jeg&amp;s"})
        db.Create(&amp;models.Quiz{Title: "Квиз по истории", Description: "Описание квиза по истории", CategoryID: 3, ImgURL: "https://auto.vercity.ru/img/magazine/2019/11/11/1573504833.jpg"})

        db.Create(&amp;models.Question{Text: "Вопрос 1", QuizID: 1})
        db.Create(&amp;models.Question{Text: "Вопрос 2", QuizID: 1})
        db.Create(&amp;models.Question{Text: "Вопрос 3", QuizID: 1})

        db.Create(&amp;models.Answer{Text: "Правильный", QuestionID: 1, IsCorrect: true})
        db.Create(&amp;models.Answer{Text: "Неправильный", QuestionID: 1, IsCorrect: false})

        db.Create(&amp;models.Answer{Text: "Неправильный", QuestionID: 2, IsCorrect: false})
        db.Create(&amp;models.Answer{Text: "Правильный", QuestionID: 2, IsCorrect: true})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "net/http"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
)

func getQuestions(c *gin.Context) <span class="cov0" title="0">{
        quizID := c.Param("id")
        var questions []models.Question
        if err := db.Where("quiz_id = ?", quizID).Preload("Answers").Find(&amp;questions).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, questions)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "net/http"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
)

type createQuizRequest struct {
        Title       string               `json:"title"`
        Description string               `json:"description"`
        CategoryID  uint                 `json:"category_id"`
        Questions   []createQuizQuestion `json:"questions"`
}

type createQuizQuestion struct {
        Text    string             `json:"text"`
        Answers []createQuizAnswer `json:"answers"`
}

type createQuizAnswer struct {
        Text      string `json:"text"`
        IsCorrect bool   `json:"is_correct"`
}

func getQuizzes(c *gin.Context) <span class="cov0" title="0">{
        var quizzes []models.Quiz
        if err := db.Find(&amp;quizzes).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, quizzes)</span>
}

func createQuiz(c *gin.Context) <span class="cov0" title="0">{
        var req createQuizRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid body"})
                return
        }</span>

        <span class="cov0" title="0">if req.Title == "" || len(req.Questions) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "title and questions are required"})
                return
        }</span>

        <span class="cov0" title="0">quiz := models.Quiz{
                Title:       req.Title,
                Description: req.Description,
                CategoryID:  req.CategoryID,
        }

        if err := db.Create(&amp;quiz).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>

        // создаём вопросы и ответы
        <span class="cov0" title="0">for i := range req.Questions </span><span class="cov0" title="0">{
                qReq := req.Questions[i]

                question := models.Question{
                        Text:   qReq.Text,
                        QuizID: quiz.ID,
                }

                if err := db.Create(&amp;question).Error; err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                        return
                }</span>

                <span class="cov0" title="0">for j := range qReq.Answers </span><span class="cov0" title="0">{
                        aReq := qReq.Answers[j]

                        answer := models.Answer{
                                Text:       aReq.Text,
                                QuestionID: question.ID,
                                IsCorrect:  aReq.IsCorrect,
                        }

                        if err := db.Create(&amp;answer).Error; err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                                return
                        }</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "id":          quiz.ID,
                "title":       quiz.Title,
                "description": quiz.Description,
                "category_id": quiz.CategoryID,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "errors"
        "log"
        "math"
        "net/http"
        "strconv"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type quizAnswers struct {
        User_id uint            `json:"user_id"`
        Answers map[uint][]uint `json:"answers"`
}

func checkTest(c *gin.Context) <span class="cov0" title="0">{
        log.Println("test checking")
        var answers quizAnswers
        totalScore := 0.0

        quizID := c.Param("id")
        var questions []models.Question
        totalQuestions := len(questions)
        if err := c.ShouldBindJSON(&amp;answers); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid body"})
                return
        }</span>

        <span class="cov0" title="0">if err := db.Where("quiz_id = ?", quizID).Preload("Answers").Find(&amp;questions).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(questions); i++ </span><span class="cov0" title="0">{
                q := questions[i]
                selectedIDs := answers.Answers[q.ID]
                if len(selectedIDs) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">selectedSet := make(map[uint]struct{})
                for j := 0; j &lt; len(selectedIDs); j++ </span><span class="cov0" title="0">{
                        id := selectedIDs[j]
                        selectedSet[id] = struct{}{}
                }</span>

                <span class="cov0" title="0">totalCorrect := 0
                correctChosen := 0
                wrongChosen := 0
                correctSet := make(map[uint]struct{})
                for j := 0; j &lt; len(q.Answers); j++ </span><span class="cov0" title="0">{
                        a := q.Answers[j]
                        if a.IsCorrect </span><span class="cov0" title="0">{
                                totalCorrect++
                                correctSet[a.ID] = struct{}{}
                        }</span>
                }
                <span class="cov0" title="0">if totalCorrect == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for id := range selectedSet </span><span class="cov0" title="0">{
                        _, ok := correctSet[id]
                        if ok </span><span class="cov0" title="0">{
                                correctChosen++
                        }</span> else<span class="cov0" title="0"> {
                                wrongChosen++
                        }</span>
                }

                <span class="cov0" title="0">queScore := float64(correctChosen-wrongChosen) / float64(totalCorrect)
                if queScore &lt; 0 </span><span class="cov0" title="0">{
                        queScore = 0
                }</span>

                <span class="cov0" title="0">totalScore += math.Round(queScore*100) / 100</span>
        }
        <span class="cov0" title="0">quizIDint, _ := strconv.ParseUint(quizID, 10, 64)
        quizIDuint := uint(quizIDint)

        var bestBefore models.Result
        bestBeforeScore := 0.0

        if err := db.
                Where("user_id = ? AND quiz_id = ?", answers.User_id, quizIDuint).
                Order("score DESC").
                First(&amp;bestBefore).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        bestBeforeScore = 0.0
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                bestBeforeScore = bestBefore.Score
        }</span>

        <span class="cov0" title="0">if totalScore &gt; bestBeforeScore </span><span class="cov0" title="0">{
                if err := db.Model(&amp;models.User{}).
                        Where("id = ?", answers.User_id).
                        Update("total_points", gorm.Expr("total_points + ?", totalScore-bestBeforeScore)).Error; err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                        return
                }</span>
        }

        <span class="cov0" title="0">result := models.Result{
                Score:    totalScore,
                MaxScore: totalQuestions,
                UserID:   answers.User_id,
                QuizID:   quizIDuint,
        }

        if err := db.Create(&amp;result).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "result exists or db error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "score":     totalScore,
                "questions": totalQuestions,
                "percent":   totalScore / float64(totalQuestions) * 100,
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "log"
        "net/http"
        "os"

        "github.com/Rzh3nk/quizzix/backend/internal/models"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"
)

var jwtSecret = []byte("SUPER_SECRET_KEY") // потом надо скрыть

// структуры для запросов
type registerRequest struct {
        Username string `json:"username"`
        Email    string `json:"email"`
        Password string `json:"password"`
}

func register(c *gin.Context) <span class="cov0" title="0">{
        log.Println("registering user")
        var req registerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid body"})
                return
        }</span>
        //сделать более хорошую проверку, когда определим требования по регистрации
        //проверку на уникальность логина, почты, маску на почту, длину всех полей
        <span class="cov0" title="0">if req.Email == "" || req.Password == "" || req.Username == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "missing fields"})
                return
        }</span>

        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "hash error"})
                return
        }</span>
        //создание пользователя
        <span class="cov0" title="0">user := models.User{
                Username: req.Username,
                Email:    req.Email,
                Password: string(hash),
        }
        //запись в бд
        if err := db.Create(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user exists or db error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "registered"})</span>
}

func login(c *gin.Context) <span class="cov0" title="0">{
        var req registerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid body"})
                return
        }</span>
        <span class="cov0" title="0">var user models.User
        //проверка по нику(можно сделать еще почту)
        if err := db.Where("username = ?", req.Username).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
                return
        }</span>
        //создание жвт
        <span class="cov0" title="0">if envSecret := os.Getenv("JWT_SECRET"); envSecret != "" </span><span class="cov0" title="0">{
                jwtSecret = []byte(envSecret)
        }</span>
        //создание токена
        <span class="cov0" title="0">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "sub": user.ID,
        })

        tokenString, err := token.SignedString(jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "token error"})
                return
        }</span>
        <span class="cov0" title="0">log.Println("login suc")
        //возвращаем данные залогиненного пользователя
        c.JSON(http.StatusOK, gin.H{
                "token":    tokenString,
                "user_id":  user.ID,
                "username": user.Username,
                "email":    user.Email,
        })</span>
}

func getUser(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var user models.User
        if err := db.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "id":       user.ID,
                "username": user.Username,
                "email":    user.Email,
                "created":  user.CreatedAt,
        })</span>
}
func getUserResults(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        var results []models.Result
        if err := db.Where("user_id = ?", id).
                Order("created_at DESC").Find(&amp;results).Error; err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, results)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
